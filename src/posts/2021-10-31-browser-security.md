---
layout: post
title: 'ブラウザセキュリティとあなたのウェブサイトに今最低限必要なこと'
description: ''
date: 2021-10-31
tags:
- Security
- Cross-origin isolation
- Spectre
---

長い記事なので先に結論を書きます。

Spectre を使うと、ユーザーが下記の条件に当てはまる攻撃者のページを誤って開くだけで、そこに記載されている情報が盗まれる可能性があります。

* iframe 内に読み込まれている
* popup ウィンドウで開かれている
* リソースがロードされている

これを防ぐためには

* HTML ドキュメントは `X-Frame-Options` もしくは Content-Security-Policy (CSP) ヘッダーの `frame-ancestors` ディレクティブを使って iframe に埋め込みを制御する。
* HTML ドキュメントは `Cross-Origin-Opener-Policy` ヘッダーを使って popup ウィンドウで開かれた場合のコミュニケーションを制御する。
* その他のセンシティブな (Cookie などでパーソならずされる可能性のある) リソースは `Cross-Origin-Resource-Policy` ヘッダーを使って埋め込みを制御する。

さらに詳しく知りたい方は続きを読んでください。

<!-- excerpt -->

## ブラウザの仕組みを振り返る

まず最初に、今のブラウザがウェブをどの用に表示しているか軽く振り返ってみましょう。

ブラウザは、各タブそれぞれがひとつの URL を持ち (その昔、ブラウザにタブはありませんでした)、現在見ているページをユーザーに教えてくれます。タブに表示されている URL は通常 HTML ドキュメントを指し、そのドキュメントが画像や動画、スタイルシート、スクリプト、フォントなど、様々なリソースを読み込むことでウェブページ全体を表現します。この時、各リソースのドメインは必ずしも現在見ているページのドメインとは一致しません。

この時、URL バーに表示されているドメインを「ファーストパーティー」、ロードされたリソースのファーストパーティー以外のドメインを「サードパーティー」と呼びます。(つまり「サードパーティー Cookie」とは、サードパーティーのリソースに紐付けられているもののことを言います。が、その話は機会があればまた別のところで・・・。)

また、2 つのドメインの関係について、eTLD (effective Top Level Domain = 例えば `example.com`) だけが同じものを same-site、スキーマ、ホスト名、ポート番号すべてが一致するもの (例えば `https://www.example.com:8080`) を same-origin、それ以外を cross-site や cross-origin と呼びます。

参考：[same-site/cross-site, same-origin/cross-origin をちゃんと理解する](https://zenn.dev/agektmr/articles/f8dcd345a88c97)

このようにウェブでは、様々なリソースを異なるサービス (ドメイン) からパズルのように組み合わせて表示することができる点 (composability) が大きな魅力です。これを利用して、画像やフォント、スクリプトやスタイルを読み込みリッチな表現をすることは、ウェブにとって当たり前のことであり、特に Web 2.0 以降は、そこに API という考え方を加えてさらに発展してきました。いくつか例を挙げてみましょう。

* スクリプトを読み込むだけでアナリティクスを導入し、サイトを訪れたユーザーの行動を分析、もしくはトラッキングする。
* iframe を使って外部サイトの情報をウィジェットとして表示し、広告やソーシャルメディアのボタン、パーソナライズ可能な地図や動画を埋め込む。
* popup ウィンドウを使って、外部サイトでのログインや支払いといった連携を実現する。

このように、ウェブはサードパーティーとの連携により多くの恩恵を受けています。

## same-origin policy

ところでウェブの世界で怖いことは、本来しかるべきところに預けたはずの情報が、ユーザーの意図しないところに渡ったり、利用されたりしてしまうことでしょう。預けた情報が例えばくだらないつぶやきならまだいいですが、クレジットカード番号や銀行口座の情報だったりしたら一大事です。そのため、ここで言う「しかるべきところ」はドメインによって表され、HTTPS を通すことでその信頼性を保証することができます。

攻撃者は様々な手段を使ってこのドメインの壁を越えようとしてきます。

例えばフィッシングという攻撃では、SMS やメールを通じて本物と似た見た目の偽サイトに誘導し、ユーザー名とパスワードを入力させて盗みます。盗んだユーザー名とパスワードを使って本物のサイトにログインし、情報を盗むというわけです。

クロスサイトスクリプティング (XSS) という攻撃では、悪意のある JavaScript を忍び込ませてブラウザに実行させることで、情報を盗みます。


しかし、様々なドメインからリソースを集めることができるブラウザ上で、サードパーティーがファーストパーティーの情報を盗み見ることはありえないのでしょうか？その境界線は一体どこにあるのでしょうか？

情報が盗まれるポイントとしてはサーバー、ネットワーク、クライアント (ブラウザ) の大きく 3 つに分かれますが、この記事ではブラウザにフォーカスを当てます。

ブラウザ上で様々なドメインからリソースを持ってきた時、どんなリスクがありえるでしょうか？

セキュリティの心配はないのでしょうか？連携先のサービスが、本来知ることのできない情報を盗み見るようなことは、本当にできないのでしょうか？

その説明を始める前に、same-origin policy について理解しておく必要があります。

こうした連携を可能にしながらもサイトごとの安全性をある程度保ってくれるのが same-origin policy です。これは origin を境界としてお互いに不可侵な関係を保ちつつも、ある程度の連携は可能にする、という実に微妙なバランスの元に成り立っています。

理想的には、ウェブ開発者に知識が足りなくても、簡単には脆弱なウェブアプリを作れないのが理想です。しかし、残念ながら今のウェブは必ずしもそうとは言い切れません。どういった部分に気をつけるべきかを説明していきましょう。

例えば埋め込み動画を例の取って考えてみましょう。この動画は iframe で埋め込まれているため、サードパーティー Cookie を使ってパーソナライズが可能になっています。閲覧しているユーザーは配信元のドメインでログイン状態であれば、そのアカウントに対して「後で見る」などのアクションが可能なため、便利に利用することができます。しかしこのアカウントの情報は、特に API が用意されていない限り、埋め込み元のサイトから script を使って見ることができません。iframe から得られる情報は限られているからです。実際 iframe の DOM ツリーを辿ってみても、…までしか情報は得られず、どんな HTML が表示されているか、ましてや Cookie の中身などを見ることは不可能になっています。

Popup ウィンドウでも同様のことが言えます。例えば支払いで Popup ウィンドウによる
連携がされている場合、DOM ツリーを辿れてしまうと、お店側がユーザーのクレジット
カード情報などを盗み見ることができることになってしまいます。

もしそれが可能だとしたら、その悪意は親サイトの脆弱性に寄りません。

## Spectre とは何だったのか

Spectre は 2018 年に発表された CPU の構造そのものに存在する脆弱性で、簡単に言ってしまえば同じプロセスで制御されているメモリ空間の値を推測できてしまうというものです。これは異なるドメインからロードした複数のプログラムを同じページ内で動作させるというウェブの特性上、大きな脅威となります。

悪意のある JavaScript をロードしてしまえば、same-origin policy の壁を無視して、同じプロセスで動いている任意の DOM 要素を読み出すことができる、ということになります。問題は、悪意のある JavaScript を読ませなければいいというわけではない点です。今のほとんどのブラウザのアーキテクチャでは Spectre を使うと、同じプロセス上で動いてさえいれば攻撃者の作ったページを開いてリソースが読み込まれるだけでも攻撃が可能です。そのためには、攻撃対象のサイトのリソースをロードしたり、iframe 内に表示したり、popup ウィンドウを開くだけで十分なのです。

これはヤバい。

これはつまり same-origin policy でブラウザが守ってきた origin による境界を無かったこと同然にしてしまうということを意味しています。

## なぜ SharedArrayBuffer などが無効化されてきたのか

高精度タイマーは攻撃を効率化する。
多くのブラウザは SAB などの機能をオフにした。

ただし Chrome だけはこれまでも SAB を使うことができました。

Site Isolation

いや、Spectre があってもなくても変わらなかったかもしれません。以前はタブごとにプロセスが立ってたものが、site ごとに変わり、さらに今後は origin ごとに変わるだろうというものです。

プロセスという単位ではなく、Browsing Context Group と呼ぶ。

これはブラウザがページを表示する際のパフォーマンスが向上することとともに、オーバーヘッドがこれまでよりも大きくなることを意味しています。また、消費メモリも自ずと増えることになるでしょう。これは Chrome だけではなく、すべてのブラウザで共通して言えることです。なぜかを説明していきます。

ブラウザにできることは、origin ごとにプロセスを分けることです。ただしプロセスが異なるということは、これまで可能だった連携ができなくなることを意味します。

例えば popup ウィンドウとの postMessage iframe 埋め込み自体できない

## 攻撃を未然に防ぐ

悪意のあるサイトが同じスクリプトを埋め込み、それをユーザーが開いてしまえば、もはやユーザーには為す術はないのです。

こういった攻撃を防ぐためにサイトができることは、不用意にサイトを埋め込ませないこと、開かせないことです。そのためにできることがいくつかあります。

Spectre による攻撃を防ぐためには、悪意あるサイトが勝手にあなたのサイトを iframe 内に表示したり、popup ウィンドウとして開いたりすることを防ぐ必要があります。現在のウェブでは、cross-origin の iframe の埋め込みや popup ウィンドウを開くのに誰の許可も必要ありません。理想的にはブラウザが自動的にこういった攻撃を防ぐことが望まれますが、それはデフォルトの挙動を変更を必要とし、今現在動いているウェブサイトが軒並み壊れてしまうことを意味しています。

そのため、Spectre による攻撃を防ぐためには、開発者が防ぐための工夫を明示的にしなければなりません。

3 つのことをおすすめします。

### `Cross-Origin-Resource-Policy` でリソースの埋め込みを制御する

画像や動画、音声、スクリプト、API 経由の JSON など、リソースのロードを `same-origin`、`same-site` に許可する、もしくはどこからでも許可する (`cross-site`) ことができます。例えば、`https://images.example.com` にホストされている画像にそれぞれのヘッダーを追加した場合の挙動は以下の通りです:

```http
Cross-Origin-Resource-Policy: same-origin
```

この画像は same-origin である `https://www.example.com` からしか読み込むことはで
きません。

```http
Cross-Origin-Resource-Policy: same-site
```

この画像は same-site である `example.com` を含むドメインからしか読み込むことはで
きません。

```http
Cross-Origin-Resource-Policy: cross-site
```

デフォルトであるこのヘッダーが付いた画像はどのドメインからでも読み込むことができます。

ここで勘違いしてはいけないのは、ブラウザはリソースをネットワークから読み込むところまではできるという点です。いわゆる ACL とは異なりますので、CORS に対応したブラウザ以外からのサーバーリクエストに対しては何の意味もありませんので、誤解のないようしましょう。実際に CORP が防ぐのは、ネットワークから読み込んだリソースをブラウザ上で BCG にロードすることです。これにより Spectre の攻撃を未然に防ぐことができます。

ここで CORS (Cross-Origin Resource Sharing) に似ていると思われた方もいるかもしれません。実際できることは似ていますが、CROS はより細かく設定ができるという点が異なります。

### `X-Frame-Options` または CSP `frame-ancestors` でドキュメントの iframe 埋め込みを制御する

ウェブサイトを勝手に iframe 内にロードして、内容を盗み見ようとする攻撃を防ぐには、`X-Frame-Options` ヘッダーを使って iframe へのロードを完全にブロックするか、CSP (Content Security Policy) ヘッダーの `frame-ancestors` ディレクティブを使って許可するオリジンを明示します。

```http
X-Frame-Options: DENY
```

```http
Content-Security-Policy: frame-ancestores 'self' https://www.example.com;
```

これだけで勝手にページを iframe にロードする攻撃を防ぐことができます。

### `Cross-Origin-Opener-Policy` で popup ウィンドウを介したコミュニケーションを制御する

ウェブサイトを popup ウィンドウで開き、情報を盗むのを防ぐには、COOP
(Cross-Origin-Opener-Policy) ヘッダーを使います。これは popup ウィンドウとして開
くこと自体は可能ですが、Browsing Context Group を別にするため、Spectre を使って
DOM を覗き見ることができなくなります。

```http
Cross-Origin-Opener-Policy: same-origin
```

これは cross-origin の popup ウィンドウを自分で開いた場合も、cross-origin のウィ
ンドウから自分のオリジンのドキュメントが開かれてしまった場合でも、BCG を分けま
す。

```http
Cross-Origin-Opener-Policy: same-origin-allow-popups
```

これは cross-origin のウィンドウから自分のオリジンのドキュメントが開かれてしまっ
た場合、BCG を分けますが、自分で cross-origin の popup ウィンドウを開いた場合は
その限りではありません。

```http
Cross-Origin-Opener-Policy: unsafe-none
```

これはデフォルトの挙動で、他のオリジンから popup ウィンドウで開かれた場合でも
BCG を分けなくてよいことを明示することができます。

COOP はこのように、自分のサイトを popup ウィンドウとして開かれることによる
Spectre を使った攻撃から守れる一方、cross-origin から popup ウィンドウとして開か
られる想定の機能、例えば OAuth や支払い系の機能においては問題となります。これに
ついては後ほど触れます。

## Cross-origin isolation

先程 Spectre を防ぐために各ブラウザは SharedArrayBuffer などの高精度タイマーを使
う機能を停止したと書きました。

## Site Isolation

SharedArrayBuffer を使うには

Site Isolation のおかげで SharedArrayBuffer が使えるようになったとはいえ、これで
一件落着というわけではありません。この実装はあくまで Chromium のプロプライエタリ
で、実装に依存しているからです。ウェブサイトが自らこの安全な状況を宣言し、ブラウザに制約を課すことで安心して SharedArrayBuffer などの機能を使える状態が標準化されるべきです。

そこで登場したのが cross-origin isolation です。ウェブサイトが自らに制約を課すこ
とで、ページが他の origin から isolate (完全に分離されている) していることを保証
し、その環境であれば SharedArrayBuffer などが再び利用できるようになります。

そのために必要な条件は 2 つのヘッダーで実現できます。

```http
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin
```


```js
if (self.crossOriginIsolated) {
  // This page is cross-origin isolated.
  const sab = new SharedArrayBuffer();
}
```

## Cross-Origin-Embedder-Policy

```http
Cross-Origin-Embedder-Policy: require-corp
```

## Cross-origin isolation は未完成

このように、cross-origin isolation を有効にすることで、SharedArrayBuffer などの
パワフルな機能が利用できるようになります。とはいえ、cross-origin isolation には
いくつか課題が残されています。



こういった問題に直面して SAB を利用できない開発者向けに、Chrome では一時的に
cross-origin isolation を有効にしなくても SharedArrayBuffer を利用できるように
Deprecation Trial を実施しています。

それと同時にこれらの問題を解決するため、3 つの提案を行っています。


```http
Cross-Origin-Emebedder-Policy: credentialless
```

anonymous iframe


```http
Cross-Origin-Opener-Policy: same-origin-allow-popups-plus-coep
```


開発者が知らなければ守られないセキュリティは健全とはいえないため、Chrome チーム
ではドラスティックな変更を提案する予定です。

* `X-Frame-Options` については、`DENY`をデフォルトに。
* `Cross-Origin-Opener-Policy` については、`same-origin-allow-popups` をデフォル
  トに。
